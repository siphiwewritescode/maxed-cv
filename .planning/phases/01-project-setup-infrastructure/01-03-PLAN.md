---
phase: 01-project-setup-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - docker-compose.yml
  - backend/Dockerfile.dev
  - frontend/Dockerfile.dev
  - package.json
  - .env.example
  - backend/.env.example
  - frontend/.env.local.example
  - .gitignore
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "docker-compose up starts all 4 services (backend, frontend, db, redis)"
    - "Backend hot reload works via bind-mounted source code"
    - "Frontend hot reload works via bind-mounted app directory"
    - "npm run dev from root starts entire stack via Docker Compose"
    - "All required npm scripts exist at root level"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Docker Compose orchestration for all services"
      contains: "services"
    - path: "backend/Dockerfile.dev"
      provides: "Development Docker image for NestJS backend"
      contains: "FROM node"
    - path: "frontend/Dockerfile.dev"
      provides: "Development Docker image for Next.js frontend"
      contains: "FROM node"
    - path: "package.json"
      provides: "Root package.json with orchestration npm scripts"
      contains: "npm run dev"
    - path: ".gitignore"
      provides: "Git ignore rules for node_modules, .env, dist, .next"
      contains: "node_modules"
  key_links:
    - from: "docker-compose.yml"
      to: "backend/Dockerfile.dev"
      via: "build context for backend service"
      pattern: "context.*backend"
    - from: "docker-compose.yml"
      to: "frontend/Dockerfile.dev"
      via: "build context for frontend service"
      pattern: "context.*frontend"
    - from: "package.json"
      to: "docker-compose.yml"
      via: "npm scripts wrapping docker-compose commands"
      pattern: "docker-compose"
    - from: "docker-compose.yml"
      to: "backend/.env.example"
      via: "environment variables for backend service"
      pattern: "DATABASE_URL"
---

<objective>
Create Docker Compose orchestration, development Dockerfiles, root npm scripts, and environment configuration files.

Purpose: Wire together the backend (Plan 01) and frontend (Plan 02) into a single-command development environment. This is the integration layer that makes `npm run dev` start everything.
Output: docker-compose.yml orchestrating 4 services, Dockerfiles for backend/frontend, root package.json with all required scripts, and environment variable templates.
</objective>

<execution_context>
@C:\Users\pc\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pc\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-setup-infrastructure/01-CONTEXT.md
@.planning/phases/01-project-setup-infrastructure/01-RESEARCH.md
@.planning/phases/01-project-setup-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-project-setup-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose and Dockerfiles</name>
  <files>
    docker-compose.yml
    backend/Dockerfile.dev
    frontend/Dockerfile.dev
    .dockerignore
  </files>
  <action>
    Create the Docker orchestration layer for local development.

    1. Create backend/Dockerfile.dev:
       - FROM node:22-alpine
       - WORKDIR /app
       - COPY package*.json ./
       - COPY prisma ./prisma/
       - RUN npm ci
       - RUN npx prisma generate
       - EXPOSE 3001
       - CMD ["npm", "run", "start:dev"]

    2. Create frontend/Dockerfile.dev:
       - FROM node:22-alpine
       - WORKDIR /app
       - COPY package*.json ./
       - RUN npm ci
       - EXPOSE 3000
       - CMD ["npm", "run", "dev"]

    3. Create docker-compose.yml (use Compose v2 format, no version field needed):
       services:
         backend:
           build:
             context: ./backend
             dockerfile: Dockerfile.dev
           volumes:
             - ./backend/src:/app/src:delegated          # Source code hot reload
             - ./backend/prisma:/app/prisma:delegated     # Schema changes
             - backend_node_modules:/app/node_modules      # Performance: named volume
           environment:
             - DATABASE_URL=postgresql://postgres:password@db:5432/maxedcv
             - REDIS_HOST=redis
             - REDIS_PORT=6379
             - NODE_ENV=development
             - PORT=3001
             - FRONTEND_URL=http://localhost:3000
           ports:
             - "3001:3001"
           command: npm run start:dev
           depends_on:
             db:
               condition: service_healthy
             redis:
               condition: service_started
           restart: unless-stopped

         frontend:
           build:
             context: ./frontend
             dockerfile: Dockerfile.dev
           volumes:
             - ./frontend/app:/app/app:delegated          # App Router pages hot reload
             - ./frontend/public:/app/public:delegated     # Static assets
             - ./frontend/lib:/app/lib:delegated           # Library code
             - frontend_node_modules:/app/node_modules     # Performance
             - frontend_next:/app/.next                    # Build cache
           environment:
             - NEXT_PUBLIC_API_URL=http://localhost:3001
             - WATCHPACK_POLLING=true                      # Required for Docker hot reload on some systems
           ports:
             - "3000:3000"
           command: npm run dev
           depends_on:
             - backend
           restart: unless-stopped

         db:
           image: postgres:16-alpine
           environment:
             - POSTGRES_USER=postgres
             - POSTGRES_PASSWORD=password
             - POSTGRES_DB=maxedcv
           volumes:
             - postgres_data:/var/lib/postgresql/data
           ports:
             - "5432:5432"
           healthcheck:
             test: ["CMD-SHELL", "pg_isready -U postgres"]
             interval: 5s
             timeout: 5s
             retries: 5

         redis:
           image: redis:7.4-alpine
           ports:
             - "6379:6379"
           restart: unless-stopped

       volumes:
         backend_node_modules:
         frontend_node_modules:
         frontend_next:
         postgres_data:

    4. Create .dockerignore at project root:
       - node_modules, .next, dist, .env, .git, *.md (except README.md)

    CRITICAL notes from research:
    - Use :delegated flag on bind mounts for macOS/Windows Docker performance
    - NEVER bind mount node_modules (use named volumes)
    - Use service name "db" as PostgreSQL hostname (NOT localhost)
    - Add healthcheck on db service so backend waits for PostgreSQL to be ready
    - Set WATCHPACK_POLLING=true for frontend hot reload in Docker
  </action>
  <verify>
    - docker-compose.yml exists and is valid YAML: `docker compose config` (or `docker-compose config`) should parse without errors
    - backend/Dockerfile.dev exists with FROM node:22-alpine
    - frontend/Dockerfile.dev exists with FROM node:22-alpine
    - docker-compose.yml defines exactly 4 services: backend, frontend, db, redis
    - docker-compose.yml defines 4 named volumes
    - Backend DATABASE_URL uses "db" as hostname (not "localhost")
  </verify>
  <done>
    Docker Compose file orchestrates 4 services (backend, frontend, db, redis) with hot reload via bind mounts, named volumes for node_modules, PostgreSQL health check, and proper service dependencies. Both Dockerfiles use node:22-alpine.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create root package.json, env templates, and gitignore</name>
  <files>
    package.json
    .env.example
    backend/.env.example
    frontend/.env.local.example
    .gitignore
  </files>
  <action>
    Create the root orchestration layer and environment configuration.

    1. Create package.json at project root:
       - name: "maxed-cv", version: "1.0.0", private: true
       - Scripts (per user's locked decisions):
         - "dev": "docker compose up"
         - "dev:build": "docker compose up --build"
         - "backend": "docker compose up backend db redis"
         - "frontend": "docker compose up frontend"
         - "stop": "docker compose down"
         - "clean": "docker compose down -v"
         - "db:migrate": "docker compose exec backend npx prisma migrate dev"
         - "db:seed": "docker compose exec backend npx prisma db seed"
         - "db:reset": "docker compose exec backend npx prisma migrate reset --force"
         - "db:studio": "docker compose exec backend npx prisma studio"
         - "logs:backend": "docker compose logs -f backend"
         - "logs:frontend": "docker compose logs -f frontend"
         - "logs": "docker compose logs -f"
         - "test:backend": "docker compose exec backend npm test"
         - "test:frontend": "docker compose exec frontend npm test"
       - No dependencies at root level (all deps are in backend/ and frontend/)

       Note: Using "docker compose" (v2, space) not "docker-compose" (v1, hyphen) per current standards. This works cross-platform as Docker Compose v2 is integrated into Docker CLI.

    2. Create .env.example at root (template for developers):
       ```
       # Database
       POSTGRES_USER=postgres
       POSTGRES_PASSWORD=password
       POSTGRES_DB=maxedcv

       # Backend
       DATABASE_URL=postgresql://postgres:password@db:5432/maxedcv
       REDIS_HOST=redis
       REDIS_PORT=6379
       NODE_ENV=development
       PORT=3001

       # Frontend
       NEXT_PUBLIC_API_URL=http://localhost:3001

       # Future: AI Provider (Phase 5)
       # GEMINI_API_KEY=your_key_here
       ```

    3. Create backend/.env.example:
       ```
       DATABASE_URL=postgresql://postgres:password@localhost:5432/maxedcv
       REDIS_HOST=localhost
       REDIS_PORT=6379
       NODE_ENV=development
       PORT=3001
       FRONTEND_URL=http://localhost:3000
       ```
       Note: Uses "localhost" for running backend outside Docker (direct npm run start:dev)

    4. Create frontend/.env.local.example:
       ```
       NEXT_PUBLIC_API_URL=http://localhost:3001
       ```

    5. Create .gitignore at project root (comprehensive):
       ```
       # Dependencies
       node_modules/

       # Build outputs
       dist/
       .next/
       out/

       # Environment files (NEVER commit secrets)
       .env
       .env.local
       .env.*.local
       !.env.example
       !.env.local.example
       !backend/.env.example
       !frontend/.env.local.example

       # IDE
       .vscode/
       .idea/
       *.swp
       *.swo

       # OS
       .DS_Store
       Thumbs.db

       # Docker
       postgres_data/

       # Prisma
       backend/prisma/migrations/**/migration_lock.toml

       # Logs
       *.log
       npm-debug.log*

       # Testing
       coverage/
       ```
  </action>
  <verify>
    - Root package.json exists with "dev" script containing "docker compose up"
    - Root package.json has all 6 required user scripts: dev, backend, frontend, db:migrate, db:seed, db:reset
    - .env.example exists with DATABASE_URL template
    - backend/.env.example exists with localhost DATABASE_URL
    - frontend/.env.local.example exists with NEXT_PUBLIC_API_URL
    - .gitignore exists and includes node_modules, .env, .next, dist
  </verify>
  <done>
    Root package.json provides all user-requested npm scripts (dev, backend, frontend, db:migrate, db:seed, db:reset) wrapping Docker Compose commands. Environment templates document all required variables. .gitignore prevents committing secrets and build artifacts.
  </done>
</task>

</tasks>

<verification>
1. `docker compose config` validates docker-compose.yml without errors
2. Root package.json contains all 6 required scripts from CONTEXT.md locked decisions
3. All .env.example files exist with documented variables
4. .gitignore covers node_modules, .env, .next, dist
5. Docker Compose defines 4 services and 4 named volumes
6. Backend service uses "db" hostname (not localhost) for DATABASE_URL
7. Both Dockerfiles use node:22-alpine base image
</verification>

<success_criteria>
- docker compose config parses without errors
- Root npm scripts match user's locked decisions (dev, backend, frontend, db:migrate, db:seed, db:reset)
- Hot reload is configured via bind mounts for source code and named volumes for node_modules
- Environment templates are comprehensive and well-documented
- .gitignore prevents accidental secret commits
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-infrastructure/01-03-SUMMARY.md`
</output>
