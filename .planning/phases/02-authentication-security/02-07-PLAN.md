---
phase: 02-authentication-security
plan: 07
type: execute
wave: 5
depends_on: ["02-06"]
files_modified:
  - frontend/app/(auth)/login/page.tsx
  - frontend/app/(auth)/signup/page.tsx
  - frontend/app/(auth)/reset-password/page.tsx
  - frontend/app/(auth)/reset-password/[token]/page.tsx
  - frontend/app/(auth)/layout.tsx
  - frontend/app/verify-email/[token]/page.tsx
  - frontend/lib/auth.ts
  - frontend/app/components/VerificationBanner.tsx
  - frontend/app/middleware.ts
  - frontend/app/dashboard/page.tsx
autonomous: false

must_haves:
  truths:
    - "User can see login page with email/password form and OAuth buttons"
    - "User can see signup page with email, password, first name, last name fields"
    - "User can navigate between login and signup pages"
    - "Login form submits to backend and establishes session"
    - "Signup form submits to backend and redirects to dashboard"
    - "User can click Google and LinkedIn OAuth buttons to start OAuth flow"
    - "User can request password reset by entering email"
    - "User can set new password via reset link"
    - "Email verification page processes token and shows result"
    - "Unverified users see verification banner but can use the app"
    - "Unauthenticated users are redirected to login from protected routes"
    - "User can log out from dashboard"
  artifacts:
    - path: "frontend/app/(auth)/login/page.tsx"
      provides: "Login page with form and OAuth buttons"
      min_lines: 50
    - path: "frontend/app/(auth)/signup/page.tsx"
      provides: "Signup page with registration form"
      min_lines: 50
    - path: "frontend/lib/auth.ts"
      provides: "Auth API client for all auth operations"
      exports: ["authAPI"]
    - path: "frontend/app/middleware.ts"
      provides: "Next.js middleware for route protection"
      contains: "NextResponse.redirect"
    - path: "frontend/app/components/VerificationBanner.tsx"
      provides: "Banner shown to unverified users"
      contains: "Verify your email"
  key_links:
    - from: "frontend/lib/auth.ts"
      to: "backend /auth/* endpoints"
      via: "fetch with credentials: 'include'"
      pattern: "credentials.*include"
    - from: "frontend/app/middleware.ts"
      to: "backend /auth/me"
      via: "session check for route protection"
      pattern: "auth/me"
    - from: "frontend/app/(auth)/login/page.tsx"
      to: "frontend/lib/auth.ts"
      via: "authAPI.login call"
      pattern: "authAPI\\.login"
---

<objective>
Create all frontend authentication pages (login, signup, reset password, email verification), auth API client, route protection middleware, verification banner, and a basic dashboard page.

Purpose: Deliver the complete user-facing auth experience. Users can register, log in (email or OAuth), verify email, reset password, and access protected routes.
Output: Working auth UI that connects to the backend API, with route protection and email verification banner.
</objective>

<execution_context>
@C:\Users\pc\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pc\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-security/02-RESEARCH.md
@.planning/phases/02-authentication-security/02-06-SUMMARY.md
@frontend/app/page.tsx
@frontend/app/layout.tsx
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth API client and auth pages (login, signup, reset password, verify email)</name>
  <files>
    frontend/lib/auth.ts
    frontend/app/(auth)/layout.tsx
    frontend/app/(auth)/login/page.tsx
    frontend/app/(auth)/signup/page.tsx
    frontend/app/(auth)/reset-password/page.tsx
    frontend/app/(auth)/reset-password/[token]/page.tsx
    frontend/app/verify-email/[token]/page.tsx
  </files>
  <action>
**Create `frontend/lib/auth.ts`:**

Auth API client class with all auth operations. Use `fetch` with `credentials: 'include'` for cookie-based sessions.

```typescript
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export const authAPI = {
  async signup(data: { email: string; password: string; firstName: string; lastName: string }) {
    const res = await fetch(`${API_URL}/auth/signup`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!res.ok) {
      const error = await res.json().catch(() => ({ message: 'Signup failed' }));
      throw new Error(error.message);
    }
    return res.json();
  },

  async login(data: { email: string; password: string; rememberMe?: boolean }) {
    const res = await fetch(`${API_URL}/auth/login`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!res.ok) {
      const error = await res.json().catch(() => ({ message: 'Login failed' }));
      throw new Error(error.message);
    }
    return res.json();
  },

  async logout() {
    const res = await fetch(`${API_URL}/auth/logout`, {
      method: 'POST',
      credentials: 'include',
    });
    return res.json();
  },

  async getMe() {
    const res = await fetch(`${API_URL}/auth/me`, {
      credentials: 'include',
    });
    if (!res.ok) return null;
    return res.json();
  },

  async forgotPassword(email: string) {
    const res = await fetch(`${API_URL}/auth/forgot-password`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email }),
    });
    return res.json();
  },

  async resetPassword(token: string, newPassword: string) {
    const res = await fetch(`${API_URL}/auth/reset-password`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token, newPassword }),
    });
    if (!res.ok) {
      const error = await res.json().catch(() => ({ message: 'Reset failed' }));
      throw new Error(error.message);
    }
    return res.json();
  },

  async verifyEmail(token: string) {
    const res = await fetch(`${API_URL}/auth/verify-email`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token }),
    });
    if (!res.ok) {
      const error = await res.json().catch(() => ({ message: 'Verification failed' }));
      throw new Error(error.message);
    }
    return res.json();
  },

  async resendVerification() {
    const res = await fetch(`${API_URL}/auth/resend-verification`, {
      method: 'POST',
      credentials: 'include',
    });
    return res.json();
  },

  getGoogleLoginUrl() {
    return `${API_URL}/auth/google`;
  },

  getLinkedInLoginUrl() {
    return `${API_URL}/auth/linkedin`;
  },
};
```

**Create `frontend/app/(auth)/layout.tsx`:**

Centered layout for auth pages. Clean, professional design (Claude's discretion on layout style). Use inline styles (consistent with Phase 1 approach -- UI library deferred).

```tsx
export default function AuthLayout({ children }: { children: React.ReactNode }) {
  return (
    <div style={{
      minHeight: '100vh',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#f8f9fa',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
    }}>
      <div style={{
        width: '100%',
        maxWidth: '440px',
        padding: '40px',
        backgroundColor: '#ffffff',
        borderRadius: '12px',
        boxShadow: '0 2px 10px rgba(0,0,0,0.08)',
      }}>
        {children}
      </div>
    </div>
  );
}
```

**Create `frontend/app/(auth)/login/page.tsx`:**

Login page with:
- Maxed-CV logo/name at top
- Email field
- Password field
- "Remember me" checkbox (per user decision: extends session to 30 days)
- "Sign in" button
- "Forgot password?" link -> /reset-password
- "Don't have an account? Sign up" link -> /signup
- Divider "or continue with"
- Google OAuth button (links to `authAPI.getGoogleLoginUrl()` -- opens as window.location.href, NOT fetch)
- LinkedIn OAuth button (links to `authAPI.getLinkedInLoginUrl()`)
- Error display for failed login (generic "Invalid credentials" message)
- Loading state on submit button

Use 'use client' directive. Manage state with useState. On submit, call authAPI.login(), on success redirect to /dashboard using `window.location.href = '/dashboard'` (full page navigation to pick up session cookie).

Claude's discretion on styling: Modern, clean, professional. Use inline styles consistent with existing frontend approach.

**Create `frontend/app/(auth)/signup/page.tsx`:**

Signup page with:
- Maxed-CV logo/name at top
- First name field
- Last name field
- Email field
- Password field (with note: "Minimum 8 characters" per user decision)
- "Create account" button
- "Already have an account? Sign in" link -> /login
- Divider "or continue with"
- Google and LinkedIn OAuth buttons (same as login page)
- Error display (show specific error from backend, e.g., "An account with this email already exists")
- Loading state

On submit, call authAPI.signup(). On success, redirect to /dashboard.

**Create `frontend/app/(auth)/reset-password/page.tsx`:**

Forgot password page (request reset link):
- Email field
- "Send reset link" button
- After submission, show success message: "If that email is registered, we sent a password reset link" (same message regardless of whether email exists -- matches backend behavior)
- "Back to login" link -> /login

**Create `frontend/app/(auth)/reset-password/[token]/page.tsx`:**

Set new password page (accessed from email link):
- Extract token from URL params
- New password field
- Confirm password field (client-side match validation)
- "Reset password" button
- On success, show "Password reset successfully" with link to /login
- On error (expired/invalid token), show error message with link to /reset-password to request new link

**Create `frontend/app/verify-email/[token]/page.tsx`:**

Email verification page (accessed from email link):
- Extract token from URL params
- On mount (useEffect), call authAPI.verifyEmail(token)
- Show loading state while verifying
- On success: "Email verified successfully!" with redirect to /dashboard (per user decision: auto-login and redirect)
- On error: "Verification failed. The link may have expired." with option to resend verification
  </action>
  <verify>
Run `cd frontend && npm run build` -- should compile without errors.
Check that all auth pages exist in the (auth) route group.
Check that frontend/lib/auth.ts exports authAPI.
Check that verify-email/[token]/page.tsx exists.
  </verify>
  <done>
Complete auth UI: login page with email/password form, "remember me" checkbox, and Google/LinkedIn OAuth buttons. Signup page with name, email, password fields and OAuth. Forgot password page requests reset link. Reset password page (from email token) sets new password. Email verification page processes verification token. All pages use consistent inline styling (professional, centered layout). Auth API client handles all backend communication with credentials: 'include' for cookie sessions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add route protection middleware, verification banner, and dashboard page</name>
  <files>
    frontend/app/middleware.ts
    frontend/app/components/VerificationBanner.tsx
    frontend/app/dashboard/page.tsx
  </files>
  <action>
**Create `frontend/app/middleware.ts`** (Next.js middleware for route protection):

NOTE: This should be at `frontend/middleware.ts` (root of frontend project, not inside app/).

```typescript
import { NextRequest, NextResponse } from 'next/server';

// Routes that require authentication
const protectedRoutes = ['/dashboard', '/profile'];
// Routes that should redirect to dashboard if already authenticated
const authRoutes = ['/login', '/signup'];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Check if route needs protection
  const isProtected = protectedRoutes.some(route => pathname.startsWith(route));
  const isAuthRoute = authRoutes.some(route => pathname.startsWith(route));

  if (isProtected || isAuthRoute) {
    // Check session by calling backend /auth/me
    // Forward the cookie from the incoming request
    const cookie = request.headers.get('cookie') || '';
    try {
      const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001'}/auth/me`, {
        headers: { cookie },
      });

      const isAuthenticated = res.ok;

      if (isProtected && !isAuthenticated) {
        // Redirect to login
        const loginUrl = new URL('/login', request.url);
        loginUrl.searchParams.set('redirect', pathname);
        return NextResponse.redirect(loginUrl);
      }

      if (isAuthRoute && isAuthenticated) {
        // Already logged in, redirect to dashboard
        return NextResponse.redirect(new URL('/dashboard', request.url));
      }
    } catch {
      // Backend unreachable -- allow access to auth routes, block protected
      if (isProtected) {
        return NextResponse.redirect(new URL('/login', request.url));
      }
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*', '/profile/:path*', '/login', '/signup'],
};
```

NOTE: In Docker, frontend middleware calls backend at localhost:3001, but from inside the Docker network it should use the service name `backend:3001`. The middleware runs server-side in Next.js, so inside Docker it needs to use `http://backend:3001` not `http://localhost:3001`. Add a separate env var for this:
- Use `INTERNAL_API_URL` (not NEXT_PUBLIC_) for server-side calls: defaults to `http://backend:3001` in Docker
- Use `NEXT_PUBLIC_API_URL` for client-side calls: stays as `http://localhost:3001`

Update docker-compose.yml backend service to add: `INTERNAL_API_URL=http://backend:3001` to the frontend service environment.

In the middleware, use: `process.env.INTERNAL_API_URL || process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001'`

**Create `frontend/app/components/VerificationBanner.tsx`:**

'use client' component. Shows a banner when user is logged in but email is not verified (per user decision: full access with banner, don't block features).

```tsx
'use client';
import { useState } from 'react';
import { authAPI } from '../../lib/auth';

export default function VerificationBanner({ emailVerified }: { emailVerified: boolean }) {
  const [resending, setResending] = useState(false);
  const [resent, setResent] = useState(false);

  if (emailVerified) return null;

  const handleResend = async () => {
    setResending(true);
    try {
      await authAPI.resendVerification();
      setResent(true);
    } catch {
      // Rate limited or error -- silently fail
    } finally {
      setResending(false);
    }
  };

  return (
    <div style={{
      backgroundColor: '#fff3cd',
      borderBottom: '1px solid #ffc107',
      padding: '10px 20px',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      fontSize: '14px',
    }}>
      <span>Please verify your email address to secure your account.</span>
      {resent ? (
        <span style={{ color: '#28a745' }}>Verification email sent!</span>
      ) : (
        <button
          onClick={handleResend}
          disabled={resending}
          style={{
            background: 'none',
            border: 'none',
            color: '#0066cc',
            cursor: 'pointer',
            textDecoration: 'underline',
            fontSize: '14px',
          }}
        >
          {resending ? 'Sending...' : 'Resend verification email'}
        </button>
      )}
    </div>
  );
}
```

**Create `frontend/app/dashboard/page.tsx`:**

Simple dashboard page (placeholder for future phases). This page is protected by middleware.

```tsx
'use client';
import { useEffect, useState } from 'react';
import { authAPI } from '../../lib/auth';
import VerificationBanner from '../components/VerificationBanner';

export default function DashboardPage() {
  const [user, setUser] = useState<any>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    authAPI.getMe().then(data => {
      setUser(data);
      setLoading(false);
    });
  }, []);

  const handleLogout = async () => {
    await authAPI.logout();
    window.location.href = '/login';
  };

  if (loading) return <div style={{ padding: '40px', textAlign: 'center' }}>Loading...</div>;

  return (
    <>
      {user && <VerificationBanner emailVerified={!!user.emailVerified} />}
      <div style={{
        maxWidth: '800px',
        margin: '0 auto',
        padding: '40px 20px',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
      }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '30px' }}>
          <h1 style={{ margin: 0, color: '#1a1a2e' }}>Dashboard</h1>
          <button
            onClick={handleLogout}
            style={{
              padding: '8px 16px',
              backgroundColor: '#dc3545',
              color: '#fff',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer',
              fontSize: '14px',
            }}
          >
            Log out
          </button>
        </div>
        <div style={{
          backgroundColor: '#f8f9fa',
          padding: '20px',
          borderRadius: '8px',
          border: '1px solid #e9ecef',
        }}>
          <p style={{ margin: '0 0 10px' }}>Welcome, <strong>{user?.firstName || user?.name || 'User'}</strong>!</p>
          <p style={{ margin: '0', color: '#666' }}>Email: {user?.email}</p>
          <p style={{ margin: '10px 0 0', color: '#999', fontSize: '14px' }}>
            Your dashboard will show your master profile and generated CVs here in future phases.
          </p>
        </div>
      </div>
    </>
  );
}
```

Also update docker-compose.yml frontend service to add: `- INTERNAL_API_URL=http://backend:3001`
  </action>
  <verify>
Run `cd frontend && npm run build` -- should compile without errors.
Check that middleware.ts exists at frontend root (not inside app/).
Check that /dashboard page exists.
Check that VerificationBanner component exists.
Check that docker-compose.yml frontend has INTERNAL_API_URL.
  </verify>
  <done>
Route protection: Next.js middleware redirects unauthenticated users to /login from protected routes (/dashboard, /profile) and redirects authenticated users away from auth routes (/login, /signup). Verification banner shows for unverified users but doesn't block access (per user decision). Dashboard page shows user info and logout button. Docker networking handled with INTERNAL_API_URL for server-side middleware calls.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete authentication system: backend auth API (signup, login, logout, OAuth, email verification, password reset, rate limiting, session management) and frontend auth UI (login, signup, reset password, verify email, protected routes, dashboard).
  </what-built>
  <how-to-verify>
Start the development environment:
```bash
npm run dev
```

Run database migration:
```bash
npm run db:migrate
```

Run seed:
```bash
npm run db:seed
```

**Test these flows:**

1. **Signup flow**: Visit http://localhost:3000/signup
   - Fill in: First Name, Last Name, Email (new email), Password (8+ chars)
   - Click "Create account"
   - Expected: Redirects to /dashboard, verification banner shows

2. **Login flow**: Visit http://localhost:3000/login
   - Use test account: test@maxedcv.com / Test@1234
   - Check the "Remember me" checkbox
   - Click "Sign in"
   - Expected: Redirects to /dashboard, shows "Welcome, Sipho!"

3. **Logout**: From dashboard, click "Log out"
   - Expected: Redirects to /login

4. **Protected route**: Visit http://localhost:3000/dashboard while logged out
   - Expected: Redirects to /login?redirect=/dashboard

5. **Password reset request**: Visit http://localhost:3000/reset-password
   - Enter an email and submit
   - Expected: Shows "If that email is registered, we sent a password reset link"

6. **Google/LinkedIn buttons visible** on login and signup pages
   - Expected: OAuth buttons displayed (may not work without credentials configured)

7. **API health**: Visit http://localhost:3001/auth/me while logged in (with cookie)
   - Expected: Returns user JSON

Report any issues with the auth flows.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
- Frontend builds without errors: `cd frontend && npm run build`
- All auth pages render (login, signup, reset-password, verify-email)
- Login with test credentials works end-to-end
- Signup creates account and redirects to dashboard
- Logout destroys session and redirects to login
- Protected routes redirect to login when unauthenticated
- Verification banner shows for unverified users
- Password reset flow shows correct messages
- OAuth buttons are displayed (functional test deferred to when credentials available)
</verification>

<success_criteria>
Complete auth UI working end-to-end with backend: signup, login (email + remember me), logout, protected route redirect, email verification page, password reset pages, verification banner for unverified users, and dashboard with logout button. All Phase 2 success criteria are testable.
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-07-SUMMARY.md`
</output>
