---
phase: 02-authentication-security
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - backend/src/auth/strategies/google.strategy.ts
  - backend/src/auth/strategies/linkedin.strategy.ts
  - backend/src/auth/guards/google-auth.guard.ts
  - backend/src/auth/guards/linkedin-auth.guard.ts
  - backend/src/auth/auth.service.ts
  - backend/src/auth/auth.controller.ts
  - backend/src/auth/auth.module.ts
autonomous: true
user_setup:
  - service: google-oauth
    why: "Google Sign-In for user authentication"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web Application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Add authorized redirect URI: http://localhost:3001/auth/google/callback"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Edit Client"
  - service: linkedin-oauth
    why: "LinkedIn Sign-In for user authentication (relevant for CV platform)"
    env_vars:
      - name: LINKEDIN_CLIENT_ID
        source: "LinkedIn Developers -> My Apps -> Select App -> Auth tab"
      - name: LINKEDIN_CLIENT_SECRET
        source: "LinkedIn Developers -> My Apps -> Select App -> Auth tab"
    dashboard_config:
      - task: "Create LinkedIn App with Sign In with LinkedIn using OpenID Connect"
        location: "LinkedIn Developers -> My Apps -> Create App"
      - task: "Add authorized redirect URL: http://localhost:3001/auth/linkedin/callback"
        location: "LinkedIn Developers -> My Apps -> Auth tab -> OAuth 2.0 settings"

must_haves:
  truths:
    - "User can sign in with Google OAuth and account is created/linked"
    - "User can sign in with LinkedIn OAuth and account is created/linked"
    - "OAuth users are auto-verified (Google/LinkedIn verify emails)"
    - "OAuth login creates session same as email/password login"
    - "Existing email/password user can link Google/LinkedIn account"
    - "OAuth strategies use state parameter for CSRF protection"
  artifacts:
    - path: "backend/src/auth/strategies/google.strategy.ts"
      provides: "Google OAuth Passport strategy"
      exports: ["GoogleStrategy"]
    - path: "backend/src/auth/strategies/linkedin.strategy.ts"
      provides: "LinkedIn OAuth Passport strategy"
      exports: ["LinkedInStrategy"]
    - path: "backend/src/auth/guards/google-auth.guard.ts"
      provides: "Google OAuth auth guard"
      exports: ["GoogleAuthGuard"]
    - path: "backend/src/auth/guards/linkedin-auth.guard.ts"
      provides: "LinkedIn OAuth auth guard"
      exports: ["LinkedInAuthGuard"]
  key_links:
    - from: "backend/src/auth/strategies/google.strategy.ts"
      to: "backend/src/auth/auth.service.ts"
      via: "findOrCreateOAuthUser"
      pattern: "authService\\.findOrCreateOAuthUser"
    - from: "backend/src/auth/auth.controller.ts"
      to: "Google/LinkedIn OAuth endpoints"
      via: "GET /auth/google and GET /auth/linkedin redirect endpoints"
      pattern: "auth/google|auth/linkedin"
---

<objective>
Implement Google and LinkedIn OAuth strategies with account creation, linking, and session establishment.

Purpose: Complete the "all three auth methods available from v1 launch" user decision. LinkedIn OAuth is especially relevant for a CV platform (users likely have LinkedIn accounts).
Output: Working OAuth login flows -- GET /auth/google, GET /auth/google/callback, GET /auth/linkedin, GET /auth/linkedin/callback.
</objective>

<execution_context>
@C:\Users\pc\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pc\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-security/02-RESEARCH.md
@.planning/phases/02-authentication-security/02-02-SUMMARY.md
@.planning/phases/02-authentication-security/02-03-SUMMARY.md
@backend/src/auth/auth.service.ts
@backend/src/auth/auth.controller.ts
@backend/src/auth/auth.module.ts
@backend/src/users/users.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google OAuth strategy and endpoints</name>
  <files>
    backend/src/auth/strategies/google.strategy.ts
    backend/src/auth/guards/google-auth.guard.ts
    backend/src/auth/auth.service.ts
    backend/src/auth/auth.controller.ts
    backend/src/auth/auth.module.ts
  </files>
  <action>
**Add `findOrCreateOAuthUser` to `backend/src/auth/auth.service.ts`:**

This method handles both Google and LinkedIn OAuth:

```typescript
async findOrCreateOAuthUser(data: {
  provider: 'google' | 'linkedin';
  providerId: string;
  email: string;
  firstName?: string;
  lastName?: string;
  avatar?: string;
}): Promise<any> {
  // 1. Check if user already exists with this OAuth provider ID
  let user;
  if (data.provider === 'google') {
    user = await this.usersService.findByGoogleId(data.providerId);
  } else {
    user = await this.usersService.findByLinkedInId(data.providerId);
  }
  if (user) return user;

  // 2. Check if user exists with this email (account linking)
  user = await this.usersService.findByEmail(data.email);
  if (user) {
    // Link OAuth provider to existing account
    await this.usersService.linkOAuthProvider(user.id, data.provider, data.providerId);
    // Update avatar if not set
    if (!user.avatar && data.avatar) {
      await this.prisma.user.update({ where: { id: user.id }, data: { avatar: data.avatar } });
    }
    return this.usersService.findById(user.id);
  }

  // 3. Create new user (OAuth users are auto-verified)
  return this.usersService.create({
    email: data.email,
    firstName: data.firstName,
    lastName: data.lastName,
    avatar: data.avatar,
    [data.provider === 'google' ? 'googleId' : 'linkedinId']: data.providerId,
    emailVerified: new Date(), // OAuth providers verify emails
  });
}
```

**Create `backend/src/auth/strategies/google.strategy.ts`:**

```typescript
@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(
    private configService: ConfigService,
    private authService: AuthService,
  ) {
    super({
      clientID: configService.get<string>('GOOGLE_CLIENT_ID'),
      clientSecret: configService.get<string>('GOOGLE_CLIENT_SECRET'),
      callbackURL: configService.get<string>('GOOGLE_CALLBACK_URL'),
      scope: ['email', 'profile'],
      state: true, // CSRF protection per research recommendation
    });
  }

  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any,
    done: Function,
  ): Promise<any> {
    const { id, name, emails, photos } = profile;
    const user = await this.authService.findOrCreateOAuthUser({
      provider: 'google',
      providerId: id,
      email: emails[0].value,
      firstName: name?.givenName,
      lastName: name?.familyName,
      avatar: photos?.[0]?.value,
    });
    done(null, user);
  }
}
```

NOTE: Only register GoogleStrategy if GOOGLE_CLIENT_ID is configured. Use conditional provider registration in auth.module.ts to avoid errors when OAuth credentials aren't set:

```typescript
const optionalProviders = [];
if (process.env.GOOGLE_CLIENT_ID) {
  optionalProviders.push(GoogleStrategy);
}
```

**Create `backend/src/auth/guards/google-auth.guard.ts`:**
```typescript
@Injectable()
export class GoogleAuthGuard extends AuthGuard('google') {}
```

**Add OAuth endpoints to `backend/src/auth/auth.controller.ts`:**

```typescript
@Get('google')
@UseGuards(GoogleAuthGuard)
async googleAuth() {
  // Guard redirects to Google
}

@Get('google/callback')
@UseGuards(GoogleAuthGuard)
async googleAuthCallback(@Req() req, @Res() res) {
  // Passport populates req.user after OAuth callback
  // Regenerate session for security
  const user = req.user;
  req.session.regenerate((err) => {
    if (err) {
      return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/login?error=session_error`);
    }
    req.session.passport = { user: user.id };
    req.session.createdAt = Date.now();
    req.session.save((err) => {
      if (err) {
        return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/login?error=session_error`);
      }
      // Redirect to frontend dashboard
      res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/dashboard`);
    });
  });
}
```

**Update `backend/src/auth/auth.module.ts`:**
Add GoogleStrategy to providers (conditionally if GOOGLE_CLIENT_ID is set).
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- GoogleStrategy compiles.
Verify that GET /auth/google route exists in auth.controller.ts.
Verify that GET /auth/google/callback route exists in auth.controller.ts.
Without OAuth credentials configured, the app should still start (strategy is conditionally registered).
  </verify>
  <done>
Google OAuth strategy created with state parameter (CSRF protection). GET /auth/google redirects to Google Sign-In. GET /auth/google/callback handles the return, finds or creates user, links existing accounts by email, and redirects to frontend dashboard with session established. Strategy is conditionally registered (app starts without Google credentials).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LinkedIn OAuth strategy and endpoints</name>
  <files>
    backend/src/auth/strategies/linkedin.strategy.ts
    backend/src/auth/guards/linkedin-auth.guard.ts
    backend/src/auth/auth.controller.ts
    backend/src/auth/auth.module.ts
  </files>
  <action>
**Create `backend/src/auth/strategies/linkedin.strategy.ts`:**

```typescript
@Injectable()
export class LinkedInStrategy extends PassportStrategy(Strategy, 'linkedin') {
  constructor(
    private configService: ConfigService,
    private authService: AuthService,
  ) {
    super({
      clientID: configService.get<string>('LINKEDIN_CLIENT_ID'),
      clientSecret: configService.get<string>('LINKEDIN_CLIENT_SECRET'),
      callbackURL: configService.get<string>('LINKEDIN_CALLBACK_URL'),
      scope: ['openid', 'profile', 'email'],
      state: true, // CSRF protection
    });
  }

  async validate(
    accessToken: string,
    refreshToken: string,
    profile: any,
    done: Function,
  ): Promise<any> {
    const { id, name, emails } = profile;
    const user = await this.authService.findOrCreateOAuthUser({
      provider: 'linkedin',
      providerId: id,
      email: emails?.[0]?.value,
      firstName: name?.givenName,
      lastName: name?.familyName,
    });
    done(null, user);
  }
}
```

NOTE: LinkedIn's scope has changed. The newer "Sign In with LinkedIn using OpenID Connect" product uses `openid`, `profile`, `email` scopes instead of the deprecated `r_emailaddress`, `r_liteprofile`. Use the newer scopes. If passport-linkedin-oauth2 doesn't support OpenID Connect scopes well, fall back to the older scopes. The research mentions `r_emailaddress` and `r_liteprofile` -- use those as fallback if needed.

Conditionally register same as Google: only if LINKEDIN_CLIENT_ID is configured.

**Create `backend/src/auth/guards/linkedin-auth.guard.ts`:**
```typescript
@Injectable()
export class LinkedInAuthGuard extends AuthGuard('linkedin') {}
```

**Add LinkedIn endpoints to `backend/src/auth/auth.controller.ts`:**

Same pattern as Google:
```typescript
@Get('linkedin')
@UseGuards(LinkedInAuthGuard)
async linkedinAuth() {
  // Guard redirects to LinkedIn
}

@Get('linkedin/callback')
@UseGuards(LinkedInAuthGuard)
async linkedinAuthCallback(@Req() req, @Res() res) {
  // Same session establishment pattern as Google callback
  const user = req.user;
  req.session.regenerate((err) => {
    if (err) {
      return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/login?error=session_error`);
    }
    req.session.passport = { user: user.id };
    req.session.createdAt = Date.now();
    req.session.save((err) => {
      if (err) {
        return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/login?error=session_error`);
      }
      res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/dashboard`);
    });
  });
}
```

**Update `backend/src/auth/auth.module.ts`:**
Add LinkedInStrategy to conditional providers (only if LINKEDIN_CLIENT_ID is set).

The final auth.module.ts should have:
- PassportModule.register({ session: true })
- UsersModule, EmailModule, SessionsModule in imports
- AuthService, LocalStrategy, SessionSerializer as required providers
- GoogleStrategy, LinkedInStrategy as conditional providers
- AuthService exported
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- LinkedInStrategy compiles.
Verify that GET /auth/linkedin and GET /auth/linkedin/callback routes exist.
Verify that auth.module.ts conditionally registers both OAuth strategies.
App should start without any OAuth credentials (strategies skipped).
  </verify>
  <done>
LinkedIn OAuth strategy created with state parameter (CSRF protection). GET /auth/linkedin redirects to LinkedIn Sign-In. GET /auth/linkedin/callback handles return, finds or creates user, links existing accounts by email. Both OAuth strategies conditionally registered (app works without credentials). findOrCreateOAuthUser handles account linking when email matches existing account.
  </done>
</task>

</tasks>

<verification>
- GET /auth/google exists and redirects to Google (when configured)
- GET /auth/google/callback handles OAuth callback
- GET /auth/linkedin exists and redirects to LinkedIn (when configured)
- GET /auth/linkedin/callback handles OAuth callback
- findOrCreateOAuthUser: creates new user if no match, links provider if email exists, returns existing if provider ID matches
- OAuth users have emailVerified set (auto-verified)
- Session regenerated after OAuth callback (prevents fixation)
- App starts without OAuth credentials (strategies conditionally registered)
- Backend compiles with `npx tsc --noEmit`
</verification>

<success_criteria>
Google and LinkedIn OAuth login flows work end-to-end. Account linking handles the case where a user signs up with email then later uses OAuth with the same email. OAuth users are auto-verified. Strategies are conditionally registered so the app works in development without OAuth credentials configured.
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-05-SUMMARY.md`
</output>
