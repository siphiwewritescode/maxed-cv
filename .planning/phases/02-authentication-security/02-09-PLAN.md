---
phase: 02-authentication-security
plan: 09
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/auth/auth.controller.ts
  - frontend/lib/auth.ts
  - backend/src/sessions/sessions.service.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can logout successfully from any page without errors"
    - "After logout, user can login again immediately without encountering session errors"
    - "Frontend logout handles backend failures gracefully by forcing local cleanup"
    - "Session cookie clears properly even if Redis operations fail"
    - "Login flow handles stale session cookies from previous failed logouts"
  artifacts:
    - path: "backend/src/auth/auth.controller.ts"
      provides: "Robust logout endpoint with guaranteed cookie clearing"
      min_lines: 260
    - path: "frontend/lib/auth.ts"
      provides: "Frontend logout with response status checking"
      min_lines: 105
    - path: "backend/src/sessions/sessions.service.ts"
      provides: "Session tracking with proper error handling"
      min_lines: 90
  key_links:
    - from: "frontend/lib/auth.ts"
      to: "backend/src/auth/auth.controller.ts"
      via: "logout API call with status check"
      pattern: "if \\(!res\\.ok\\)"
    - from: "backend/src/auth/auth.controller.ts"
      to: "backend/src/sessions/sessions.service.ts"
      via: "removeUserSession with error handling"
      pattern: "try.*catch.*removeUserSession"
    - from: "backend/src/auth/auth.controller.ts"
      to: "req.session.destroy"
      via: "session cleanup always clears cookie"
      pattern: "res\\.clearCookie.*connect\\.sid"
---

<objective>
Fix critical logout/re-login bug where users cannot log back in after logout due to session regeneration race conditions and inadequate error handling.

Purpose: Ensure reliable authentication flow without session-related errors when users logout and immediately attempt to login again. This addresses UAT Gap 2 (critical severity) where user lindangwaluko6@gmail.com could not log back in after logout.

Output: Robust logout flow that guarantees cookie clearing, proper frontend error handling, and session tracking cleanup even when Redis operations fail.
</objective>

<execution_context>
@C:\Users\pc\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pc\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\pc\Documents\01 Linda\Admin\Learning\maxed-cv\.planning\PROJECT.md
@C:\Users\pc\Documents\01 Linda\Admin\Learning\maxed-cv\.planning\ROADMAP.md
@C:\Users\pc\Documents\01 Linda\Admin\Learning\maxed-cv\.planning\STATE.md
@C:\Users\pc\Documents\01 Linda\Admin\Learning\maxed-cv\.planning\phases\02-authentication-security\02-authentication-security-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix backend logout endpoint to guarantee cookie clearing</name>
  <files>backend/src/auth/auth.controller.ts</files>
  <action>
Update logout endpoint (lines 103-122) to ensure cookie ALWAYS clears even if Redis session tracking fails:

**Current issue:**
- If removeUserSession() throws (Redis down), session.destroy() never runs
- If session.destroy() callback gets error, cookie might not clear properly
- Frontend doesn't check response status, so errors are silent

**Changes:**

1. Add Logger import and instantiate at class level:
```typescript
import { Logger } from '@nestjs/common'; // Add to imports if not present

// Add to class properties (around line 27):
private readonly logger = new Logger(AuthController.name);
```

2. Wrap removeUserSession in try-catch (lines 106-113):
```typescript
// Add logging at start of logout
this.logger.log(`Logout initiated for user ${session.passport.user}, sessionID: ${req.sessionID}`);

// Wrap removeUserSession in try-catch
try {
  await this.sessionsService.removeUserSession(
    session.passport.user,
    req.sessionID,
  );
} catch (err) {
  this.logger.warn(`Failed to remove session tracking for user ${session.passport.user}: ${err.message}`);
  // Continue with logout - tracking failure shouldn't block user logout
}
```

3. Always clear cookie regardless of session.destroy() success (lines 115-121):
```typescript
req.session.destroy((err) => {
  if (err) {
    this.logger.error(`Session destroy failed: ${err.message}`);
    // Still clear cookie even if destroy failed
  }
  // ALWAYS clear cookie - this is critical for preventing stale session state
  res.clearCookie('connect.sid', {
    path: '/',
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });
  res.json({ message: 'Logged out successfully' });
});
```

**Why this fixes the issue:**
- Cookie clearing is guaranteed (even if Redis/session.destroy fails)
- User won't have stale cookie interfering with next login
- Logging provides visibility for future debugging
- Race condition resolved: cookie always clears, new login gets fresh session

**Key insight from root cause analysis:**
The race condition occurs when:
1. Logout fails to clear cookie (due to Redis/destroy error)
2. User attempts new login
3. Browser sends stale cookie with old sessionID
4. session.regenerate() tries to replace old session but old session is corrupt
5. Login fails with "session error"

By ALWAYS clearing the cookie (even on error), we ensure step 3 never happens.
  </action>
  <verify>
1. Check that Logger is imported from @nestjs/common
2. Verify logger is instantiated at class level: `private readonly logger = new Logger(AuthController.name);`
3. Verify logging at start of logout: `this.logger.log(...)`
4. Verify try-catch wraps removeUserSession call
5. Verify res.clearCookie has explicit options (path, httpOnly, secure, sameSite)
6. Verify res.clearCookie is called outside the error condition (always runs)
7. Verify logging for errors: `this.logger.error(...)`
8. Run: `cd backend && npm run build` (should compile without errors)
  </verify>
  <done>
- Logger imported and instantiated
- Logout endpoint has try-catch around Redis operations
- Cookie clearing is unconditional (happens even on error)
- Comprehensive logging exists for debugging
- Backend compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix frontend logout to check response status and handle failures gracefully</name>
  <files>frontend/lib/auth.ts</files>
  <action>
Update logout function (lines 32-38) to check response status and handle failures gracefully:

**Current issue:**
- Frontend doesn't check `res.ok` status
- If backend returns 500, frontend still treats it as success
- No local cleanup attempt if backend fails

**Changes:**

Replace current logout function:
```typescript
async logout() {
  const res = await fetch(`${API_URL}/auth/logout`, {
    method: 'POST',
    credentials: 'include',
  });

  if (!res.ok) {
    // Backend logout failed, but we should still clear local state
    console.warn('Backend logout failed, forcing local cleanup');
    // Note: Browser will clear session cookie when navigating to /login
    // due to server clearing it, but we log the warning for debugging
  }

  // Always return success object - frontend should clear local state
  // and redirect to login regardless of backend status
  return { message: 'Logged out successfully' };
}
```

**Why this fixes the issue:**
- Frontend acknowledges backend failures (logged for debugging)
- Even if backend fails, frontend continues with logout flow (redirects to login)
- Next login attempt will create fresh session (server will clear stale cookie if it exists)
- User experience is graceful (doesn't get stuck in error state)

**Note on browser behavior:**
- Session cookies are httpOnly, so frontend can't delete them directly
- Backend's res.clearCookie() in Task 1 ensures cookie is cleared server-side
- If cookie exists on next login, session.regenerate() will replace it with new session
- The key fix is in Task 1 (backend always clears cookie) - this Task 2 just improves visibility

**Alternative considered but rejected:**
We could throw an error if backend fails, but this would break the logout UX. Better to log warning and let user proceed - they'll be redirected to login page, and any stale cookie will be handled by Task 1's guaranteed clearing.
  </action>
  <verify>
1. Verify logout function checks `res.ok` status
2. Verify console.warn exists for backend failure case
3. Verify function always returns success object (doesn't throw)
4. Verify credentials: 'include' is still present (needed for cookie handling)
5. Verify comment explains browser/cookie behavior
6. Run: `cd frontend && npm run build` (should compile without errors)
  </verify>
  <done>
- Frontend logout checks response status
- Warning logged if backend fails
- Function always returns success (doesn't break logout flow)
- Frontend compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 3: Add defensive error handling to session tracking service</name>
  <files>backend/src/sessions/sessions.service.ts</files>
  <action>
Add try-catch blocks to critical Redis operations to prevent throwing errors that would break auth flows:

**Current issue:**
- If Redis is temporarily unavailable, removeUserSession throws
- This bubbles up to auth.controller logout and breaks the logout flow
- Same issue could affect addUserSession during login

**Changes:**

1. Wrap addUserSession operations (lines 18-44):
```typescript
async addUserSession(userId: string, sessionId: string): Promise<void> {
  try {
    const setKey = `user:${userId}:sessions`;

    // Add the new session
    await this.redis.sadd(setKey, sessionId);

    // Check if we've exceeded the limit
    const sessionCount = await this.redis.scard(setKey);

    if (sessionCount > this.MAX_SESSIONS) {
      // Get all sessions
      const sessions = await this.redis.smembers(setKey);

      // Sort to get oldest (first in set)
      const oldestSessionId = sessions[0];

      // Remove from user's session set
      await this.redis.srem(setKey, oldestSessionId);

      // Destroy the actual session data
      await this.redis.del(`sess:${oldestSessionId}`);

      this.logger.log(
        `Evicted oldest session ${oldestSessionId} for user ${userId} (max ${this.MAX_SESSIONS} sessions)`,
      );
    }
  } catch (err) {
    this.logger.error(
      `Failed to add/track session for user ${userId}: ${err.message}`,
    );
    // Don't throw - session will still work, just won't be tracked
    // This allows auth flow to continue even if Redis is temporarily down
  }
}
```

2. Wrap removeUserSession operations (lines 47-50):
```typescript
async removeUserSession(userId: string, sessionId: string): Promise<void> {
  try {
    const setKey = `user:${userId}:sessions`;
    await this.redis.srem(setKey, sessionId);
  } catch (err) {
    this.logger.error(
      `Failed to remove session tracking for user ${userId}: ${err.message}`,
    );
    // Don't throw - logout should proceed even if tracking cleanup fails
  }
}
```

3. Wrap removeAllUserSessions operations (lines 57-73):
```typescript
async removeAllUserSessions(userId: string): Promise<void> {
  try {
    const setKey = `user:${userId}:sessions`;

    // Get all session IDs
    const sessionIds = await this.redis.smembers(setKey);

    // Destroy each session
    for (const sessionId of sessionIds) {
      await this.redis.del(`sess:${sessionId}`);
    }

    // Clear the tracking set
    await this.redis.del(setKey);

    this.logger.log(
      `Removed all ${sessionIds.length} sessions for user ${userId}`,
    );
  } catch (err) {
    this.logger.error(
      `Failed to remove all sessions for user ${userId}: ${err.message}`,
    );
    // Don't throw - operation should be considered complete even if Redis fails
  }
}
```

**Why this fixes the issue:**
- Redis failures won't break auth flows (login/logout/password reset)
- Session tracking is best-effort, not critical path
- Errors are logged for monitoring but don't block users
- Multi-device limit enforcement degrades gracefully if Redis is down

**Trade-off accepted:**
- If Redis is down, multi-device limit won't be enforced temporarily
- This is acceptable because user authentication still works
- Once Redis recovers, tracking resumes normally
- Security impact is low: worst case is user can have >3 sessions temporarily

**Note on getUserSessions and getSessionCount methods:**
These are query methods (not called during auth flows), so we leave them without try-catch. If they throw, calling code should handle it (they're not on critical path).
  </action>
  <verify>
1. Verify all three methods (addUserSession, removeUserSession, removeAllUserSessions) have try-catch blocks
2. Verify catch blocks log errors with this.logger.error
3. Verify catch blocks DON'T re-throw errors
4. Verify original functionality is preserved inside try blocks
5. Verify getUserSessions and getSessionCount are left unchanged (not on critical path)
6. Run: `cd backend && npm run build` (should compile without errors)
  </verify>
  <done>
- All Redis operations wrapped in try-catch (addUserSession, removeUserSession, removeAllUserSessions)
- Errors logged but not thrown
- Session tracking degrades gracefully if Redis fails
- Backend compiles successfully
  </done>
</task>

</tasks>

<verification>
1. **Code verification:**
   - Run `cd backend && npm run build` (should compile without errors)
   - Run `cd frontend && npm run build` (should compile without errors)
   - Verify Logger import exists in auth.controller.ts
   - Verify all try-catch blocks exist in sessions.service.ts

2. **Manual testing (required after deployment):**
   - Test normal logout flow: Login → Logout → Login again (should work smoothly)
   - Test with account lindangwaluko6@gmail.com specifically (the account that reported the issue)
   - Test rapid logout/login cycles: Click logout, immediately click login multiple times
   - Check backend logs for proper logging of logout operations

3. **Browser DevTools verification:**
   - Clear browser cookies completely
   - Login successfully
   - Open DevTools → Application → Cookies (should see connect.sid)
   - Logout
   - Check cookies again (connect.sid should be gone)
   - Login again immediately (should work without errors)

4. **Redis failure simulation (optional but recommended):**
   - Stop Redis container: `docker compose stop redis`
   - Attempt login (should work but log Redis error in backend console)
   - Attempt logout (should work but log Redis error in backend console)
   - Restart Redis: `docker compose start redis`
   - Verify normal operation resumes

5. **Rate limiting interaction test:**
   - Logout and login 5 times rapidly
   - Should NOT hit rate limit (5 login attempts per minute)
   - If rate limited, wait 60 seconds and verify can login again
</verification>

<success_criteria>
UAT Gap 2 fully resolved:
- [ ] Backend logout endpoint always clears cookie (even on Redis/destroy errors)
- [ ] Frontend logout checks response status and logs failures
- [ ] Session tracking service has defensive error handling (doesn't throw)
- [ ] Backend compiles successfully with new logging
- [ ] Frontend compiles successfully with status check
- [ ] Manual test: User can logout and immediately login without errors
- [ ] Manual test: Account lindangwaluko6@gmail.com can logout and re-login successfully
- [ ] Backend logs show proper tracking of logout operations
- [ ] Cookie 'connect.sid' is cleared after logout (verify in browser devtools)
- [ ] Rapid logout/login cycles work without session errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-09-SUMMARY.md` with:
- Changes made to each file (logout endpoint, frontend logout, session service)
- Root cause explanation (session regeneration race condition, inadequate error handling)
- How the fix addresses UAT Gap 2
- Verification results (build success, manual test results)
- Any remaining concerns or follow-up items
</output>
