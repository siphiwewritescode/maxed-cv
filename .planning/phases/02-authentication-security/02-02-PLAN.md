---
phase: 02-authentication-security
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/users/users.module.ts
  - backend/src/users/users.service.ts
  - backend/src/auth/auth.module.ts
  - backend/src/auth/auth.service.ts
  - backend/src/auth/auth.controller.ts
  - backend/src/auth/strategies/local.strategy.ts
  - backend/src/auth/strategies/session.serializer.ts
  - backend/src/auth/guards/local-auth.guard.ts
  - backend/src/auth/guards/authenticated.guard.ts
  - backend/src/auth/decorators/current-user.decorator.ts
  - backend/src/auth/dto/signup.dto.ts
  - backend/src/auth/dto/login.dto.ts
  - backend/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "User can sign up with email, password, firstName, and lastName"
    - "User can log in with email and password"
    - "User can log out and session is destroyed"
    - "Passwords are hashed with bcrypt (work factor 13)"
    - "Session is regenerated after login (prevents session fixation)"
    - "Protected routes reject unauthenticated requests with 401"
  artifacts:
    - path: "backend/src/users/users.service.ts"
      provides: "User CRUD operations with password hashing"
      exports: ["UsersService"]
    - path: "backend/src/auth/auth.service.ts"
      provides: "Authentication business logic (validate, signup, login)"
      exports: ["AuthService"]
    - path: "backend/src/auth/auth.controller.ts"
      provides: "Auth HTTP endpoints (signup, login, logout, me)"
      exports: ["AuthController"]
    - path: "backend/src/auth/guards/authenticated.guard.ts"
      provides: "Route protection guard"
      exports: ["AuthenticatedGuard"]
  key_links:
    - from: "backend/src/auth/strategies/local.strategy.ts"
      to: "backend/src/auth/auth.service.ts"
      via: "validate method call"
      pattern: "authService\\.validateUser"
    - from: "backend/src/auth/auth.service.ts"
      to: "backend/src/users/users.service.ts"
      via: "user lookup and password comparison"
      pattern: "usersService\\.findByEmail"
    - from: "backend/src/auth/auth.controller.ts"
      to: "express-session"
      via: "req.session for login/logout"
      pattern: "req\\.session"
---

<objective>
Create the Users module (CRUD + password hashing) and Auth module (local strategy, signup, login, logout) with Passport guards and session serialization.

Purpose: Deliver the core authentication flow -- users can register, log in with email/password, log out, and access protected routes.
Output: Working POST /auth/signup, POST /auth/login, POST /auth/logout, GET /auth/me endpoints.
</objective>

<execution_context>
@C:\Users\pc\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pc\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-security/02-RESEARCH.md
@.planning/phases/02-authentication-security/02-01-SUMMARY.md
@backend/prisma/schema.prisma
@backend/src/main.ts
@backend/src/app.module.ts
@backend/src/prisma/prisma.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Users module with password hashing</name>
  <files>
    backend/src/users/users.module.ts
    backend/src/users/users.service.ts
  </files>
  <action>
**Create `backend/src/users/users.service.ts`:**

Injectable service with these methods:

1. `findByEmail(email: string): Promise<User | null>` -- Find user by email using Prisma. Return full user object including passwordHash (caller decides what to expose).

2. `findById(id: string): Promise<User | null>` -- Find user by ID. Exclude passwordHash from return using Prisma `select` or manual omission.

3. `findByGoogleId(googleId: string): Promise<User | null>` -- Find user by Google OAuth ID.

4. `findByLinkedInId(linkedinId: string): Promise<User | null>` -- Find user by LinkedIn OAuth ID.

5. `create(data: { email: string; passwordHash?: string; firstName?: string; lastName?: string; name?: string; googleId?: string; linkedinId?: string; avatar?: string; emailVerified?: Date | null }): Promise<User>` -- Create user with Prisma. Set `name` from `firstName + lastName` if not provided.

6. `updateEmailVerified(userId: string, date: Date): Promise<User>` -- Mark email as verified.

7. `updatePassword(userId: string, passwordHash: string): Promise<User>` -- Update password hash.

8. `linkOAuthProvider(userId: string, provider: 'google' | 'linkedin', providerId: string): Promise<User>` -- Link OAuth provider to existing user by setting googleId or linkedinId.

Inject `PrismaService` via constructor. Import from `../prisma/prisma.service`.

**Create `backend/src/users/users.module.ts`:**

Standard NestJS module. Import PrismaModule (it's global, so technically not needed, but explicit is clearer). Provide and export UsersService.

```typescript
@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- UsersModule and UsersService compile without TypeScript errors (note: app.module.ts not updated yet, so this checks type safety only).
  </verify>
  <done>
UsersModule exports UsersService with findByEmail, findById, findByGoogleId, findByLinkedInId, create, updateEmailVerified, updatePassword, and linkOAuthProvider methods. All methods use PrismaService for database operations. Passwords are never returned from findById.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Auth module with local strategy, signup, login, logout</name>
  <files>
    backend/src/auth/auth.module.ts
    backend/src/auth/auth.service.ts
    backend/src/auth/auth.controller.ts
    backend/src/auth/strategies/local.strategy.ts
    backend/src/auth/strategies/session.serializer.ts
    backend/src/auth/guards/local-auth.guard.ts
    backend/src/auth/guards/authenticated.guard.ts
    backend/src/auth/decorators/current-user.decorator.ts
    backend/src/auth/dto/signup.dto.ts
    backend/src/auth/dto/login.dto.ts
    backend/src/app.module.ts
  </files>
  <action>
**Create DTOs:**

`backend/src/auth/dto/signup.dto.ts`:
- `email: string` -- IsEmail, required
- `password: string` -- MinLength(8) per user decision (simple, 8 chars minimum, no complexity)
- `firstName: string` -- IsString, IsNotEmpty
- `lastName: string` -- IsString, IsNotEmpty

Use class-validator decorators (@IsEmail, @MinLength, @IsString, @IsNotEmpty).

`backend/src/auth/dto/login.dto.ts`:
- `email: string` -- IsEmail, required
- `password: string` -- IsString, required
- `rememberMe: boolean` -- IsOptional, IsBoolean, default false

**Create `backend/src/auth/auth.service.ts`:**

Injectable service. Inject UsersService.

1. `validateUser(email: string, password: string): Promise<UserWithoutPassword | null>`:
   - Find user by email via UsersService
   - If no user, return null (do NOT reveal user doesn't exist)
   - If user has no passwordHash (OAuth-only user), return null
   - Compare password with bcrypt.compare()
   - If valid, return user without passwordHash
   - If invalid, return null

2. `signup(dto: SignupDto): Promise<User>`:
   - Check if email already exists. If so, throw ConflictException('An account with this email already exists')
   - Hash password with bcrypt, salt rounds = 13 (per research: work factor 13 for 2026 security)
   - Create user via UsersService.create({ email, passwordHash, firstName, lastName })
   - Return created user (without passwordHash)

3. `hashPassword(password: string): Promise<string>`:
   - `return bcrypt.hash(password, 13);`

**Create `backend/src/auth/strategies/local.strategy.ts`:**

Extend PassportStrategy(Strategy) from passport-local. Configure with `usernameField: 'email'`. In validate method, call authService.validateUser(). If null, throw UnauthorizedException('Invalid credentials'). Generic message prevents user enumeration.

**Create `backend/src/auth/strategies/session.serializer.ts`:**

Implement PassportSerializer. In serializeUser, store only user.id in session (not full user object -- prevents session bloat). In deserializeUser, fetch user by ID from UsersService (exclude passwordHash).

```typescript
@Injectable()
export class SessionSerializer extends PassportSerializer {
  constructor(private usersService: UsersService) {
    super();
  }

  serializeUser(user: any, done: Function): void {
    done(null, user.id);
  }

  async deserializeUser(userId: string, done: Function): Promise<void> {
    const user = await this.usersService.findById(userId);
    done(null, user);
  }
}
```

**Create `backend/src/auth/guards/local-auth.guard.ts`:**

Simple AuthGuard('local') extending from @nestjs/passport. Used on login endpoint.

**Create `backend/src/auth/guards/authenticated.guard.ts`:**

CanActivate guard. Check `request.isAuthenticated()` (Passport method) OR check `request.session?.passport?.user`. If not authenticated, throw UnauthorizedException('You must be logged in'). This guard is used on any protected route.

**Create `backend/src/auth/decorators/current-user.decorator.ts`:**

createParamDecorator that extracts `request.user` from the execution context. This user is populated by Passport's deserializeUser.

**Create `backend/src/auth/auth.controller.ts`:**

Endpoints:

1. `POST /auth/signup`:
   - Accepts SignupDto (validated by global ValidationPipe)
   - Calls authService.signup(dto)
   - After creating user, log them in by setting session: `req.session.passport = { user: newUser.id }`
   - Actually, better approach: manually call `req.login(user, callback)` which uses Passport's serialize
   - Return `{ message: 'Account created successfully', user: { id, email, firstName, lastName } }`

2. `POST /auth/login`:
   - Use @UseGuards(LocalAuthGuard) -- Passport handles validation
   - After Passport validates, regenerate session to prevent session fixation:
     ```typescript
     const user = req.user;
     return new Promise((resolve, reject) => {
       req.session.regenerate((err) => {
         if (err) return reject(new InternalServerErrorException('Session error'));
         req.session.passport = { user: user.id }; // Re-serialize after regeneration
         // Set rememberMe flag and createdAt for absolute expiry tracking
         req.session.rememberMe = loginDto.rememberMe;
         req.session.createdAt = Date.now();
         if (loginDto.rememberMe) {
           req.session.cookie.maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days per user decision
         }
         req.session.save((err) => {
           if (err) return reject(new InternalServerErrorException('Session error'));
           resolve({ message: 'Login successful', user: { id: user.id, email: user.email, firstName: user.firstName, lastName: user.lastName } });
         });
       });
     });
     ```

3. `POST /auth/logout`:
   - Destroy session: `req.session.destroy()`, clear cookie: `res.clearCookie('connect.sid')`
   - Return `{ message: 'Logged out successfully' }`

4. `GET /auth/me`:
   - Use @UseGuards(AuthenticatedGuard)
   - Use @CurrentUser() decorator to get user
   - Return user object (id, email, firstName, lastName, emailVerified, avatar)

**Update `backend/src/app.module.ts`:**

Import ConfigModule.forRoot() (for @nestjs/config), UsersModule, and AuthModule.

```typescript
@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    PrismaModule,
    HealthModule,
    UsersModule,
    AuthModule,
  ],
})
export class AppModule {}
```

**Create `backend/src/auth/auth.module.ts`:**

Import PassportModule.register({ session: true }), UsersModule. Provide AuthService, LocalStrategy, SessionSerializer. Export AuthService.
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- all auth files compile.
Run `cd backend && npm test -- --passWithNoTests` -- no test failures.
If Docker is available, start services and test:
- `curl -X POST http://localhost:3001/auth/signup -H "Content-Type: application/json" -d '{"email":"test2@test.com","password":"password123","firstName":"Test","lastName":"User"}'` -- returns 201
- `curl -X POST http://localhost:3001/auth/login -H "Content-Type: application/json" -d '{"email":"test2@test.com","password":"password123"}' -c cookies.txt` -- returns 200 with Set-Cookie header
- `curl -X GET http://localhost:3001/auth/me -b cookies.txt` -- returns user object
- `curl -X POST http://localhost:3001/auth/logout -b cookies.txt` -- returns 200
- `curl -X GET http://localhost:3001/auth/me -b cookies.txt` -- returns 401
  </verify>
  <done>
Working auth flow: POST /auth/signup creates user with bcrypt-hashed password (work factor 13) and auto-logs in. POST /auth/login validates credentials via Passport local strategy, regenerates session (prevents fixation), and supports rememberMe (7-day default, 30-day extended per user decision). POST /auth/logout destroys session. GET /auth/me returns current user behind AuthenticatedGuard. Session stores only user ID (not full object). Generic "Invalid credentials" error prevents user enumeration.
  </done>
</task>

</tasks>

<verification>
- Backend compiles with `npx tsc --noEmit`
- POST /auth/signup creates user and returns user object
- POST /auth/login returns 200 with session cookie
- GET /auth/me returns user when authenticated, 401 when not
- POST /auth/logout destroys session
- Passwords stored as bcrypt hashes (not plaintext)
- Session regenerated after login (different session ID before and after)
- rememberMe=true sets cookie maxAge to 30 days
</verification>

<success_criteria>
Users can sign up with email/password, log in, access protected routes, and log out. Sessions are stored in Redis with 7-day default / 30-day "remember me" expiry. Passwords are hashed with bcrypt work factor 13. Session fixation is prevented by regenerating session ID after login.
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-02-SUMMARY.md`
</output>
