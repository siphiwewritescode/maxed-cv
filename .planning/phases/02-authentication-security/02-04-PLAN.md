---
phase: 02-authentication-security
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - backend/src/auth/auth.service.ts
  - backend/src/auth/auth.controller.ts
  - backend/src/auth/auth.module.ts
  - backend/src/auth/dto/reset-password.dto.ts
  - backend/src/auth/dto/forgot-password.dto.ts
autonomous: true

must_haves:
  truths:
    - "User receives verification email after signup with 24-hour token"
    - "User can verify email by clicking link and token is consumed (one-time use)"
    - "User can resend verification email (rate-limited to once per 5 minutes)"
    - "User can request password reset and receives email with 1-hour token"
    - "User can reset password with valid token and all sessions are invalidated"
    - "Password changed notification email is sent after successful reset"
    - "Invalid/expired tokens return clear error messages"
    - "Password reset doesn't reveal whether email exists"
  artifacts:
    - path: "backend/src/auth/auth.service.ts"
      provides: "Email verification and password reset business logic"
      contains: "sendVerificationEmail"
    - path: "backend/src/auth/auth.controller.ts"
      provides: "Verification and reset HTTP endpoints"
      contains: "verify-email"
    - path: "backend/src/auth/dto/reset-password.dto.ts"
      provides: "Reset password DTO with token and newPassword"
      exports: ["ResetPasswordDto"]
  key_links:
    - from: "backend/src/auth/auth.service.ts"
      to: "backend/src/email/email.service.ts"
      via: "email sending for verification and reset"
      pattern: "emailService\\.send"
    - from: "backend/src/auth/auth.service.ts"
      to: "backend/src/sessions/sessions.service.ts"
      via: "invalidate all sessions on password reset"
      pattern: "sessionsService\\.removeAllUserSessions"
    - from: "backend/src/auth/auth.service.ts"
      to: "prisma verificationToken/passwordResetToken"
      via: "token storage with SHA-256 hashing"
      pattern: "createHash.*sha256"
---

<objective>
Implement email verification flow (send, verify, resend) and password reset flow (request, reset, notify) with secure token handling.

Purpose: Complete AUTH-01, AUTH-03, AUTH-04 requirements -- users can verify their email and recover forgotten passwords securely.
Output: Working verification and password reset endpoints with email delivery and secure token management.
</objective>

<execution_context>
@C:\Users\pc\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pc\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-security/02-RESEARCH.md
@.planning/phases/02-authentication-security/02-02-SUMMARY.md
@.planning/phases/02-authentication-security/02-03-SUMMARY.md
@backend/src/auth/auth.service.ts
@backend/src/auth/auth.controller.ts
@backend/src/auth/auth.module.ts
@backend/src/email/email.service.ts
@backend/src/sessions/sessions.service.ts
@backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement email verification flow</name>
  <files>
    backend/src/auth/auth.service.ts
    backend/src/auth/auth.controller.ts
    backend/src/auth/auth.module.ts
  </files>
  <action>
**Update `backend/src/auth/auth.module.ts`:**

Add imports for EmailModule and SessionsModule so AuthService can inject EmailService and SessionsService.

**Update `backend/src/auth/auth.service.ts`:**

Inject EmailService, SessionsService, and PrismaService in constructor (alongside existing UsersService).

Add these methods:

1. `sendVerificationEmail(userId: string, email: string): Promise<void>`:
   - Generate token: `const token = randomBytes(32).toString('hex')` (import from 'crypto')
   - Hash token before storing: `const hashedToken = createHash('sha256').update(token).digest('hex')` (import from 'crypto')
   - Delete any existing verification tokens for this user (prevent duplicates)
   - Store hashed token in database: `prisma.verificationToken.create({ data: { userId, token: hashedToken, expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) } })` -- 24 hours per user decision
   - Build verification URL: `${process.env.FRONTEND_URL || 'http://localhost:3000'}/verify-email/${token}` -- send UNHASHED token in email
   - Call `emailService.sendVerificationEmail(email, verificationUrl)`

2. `verifyEmail(token: string): Promise<{ userId: string }>`:
   - Hash incoming token: `createHash('sha256').update(token).digest('hex')`
   - Find token in database where `token = hashedToken AND expiresAt > now()`
   - If not found, throw BadRequestException('Invalid or expired verification token')
   - Update user: `usersService.updateEmailVerified(verificationToken.userId, new Date())`
   - Delete used token: `prisma.verificationToken.delete({ where: { id: verificationToken.id } })`
   - Return `{ userId: verificationToken.userId }` -- caller can auto-login per user decision

3. `resendVerificationEmail(userId: string, email: string): Promise<void>`:
   - Check if email is already verified. If so, throw BadRequestException('Email already verified')
   - Delete existing verification tokens for this user
   - Call sendVerificationEmail(userId, email)

**Update signup method** in auth.service.ts: After creating the user, call `this.sendVerificationEmail(newUser.id, newUser.email)`. The user gets full access immediately (per user decision: show banner but don't block features), the email is just for verification.

**Update `backend/src/auth/auth.controller.ts`:**

Add endpoints:

1. `POST /auth/verify-email` -- Body: `{ token: string }`:
   - Call authService.verifyEmail(token)
   - Per user decision: auto-login user and redirect to dashboard. Return the user data so frontend can establish session.
   - Actually: log the user in by calling req.login() with the verified user
   - Return `{ message: 'Email verified successfully', user: { id, email, ... } }`

2. `POST /auth/resend-verification` -- Protected by AuthenticatedGuard (must be logged in):
   - Get current user from @CurrentUser()
   - Call authService.resendVerificationEmail(user.id, user.email)
   - Return `{ message: 'Verification email sent' }`
   - Note: Rate limiting will be added in Plan 06 (rate limiting setup)
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- all files compile.
If Docker available:
- Sign up a new user and check that verification token exists in database (via Prisma Studio)
- POST /auth/verify-email with the token -- should return success and mark email as verified
- POST /auth/resend-verification while logged in -- should send new email
  </verify>
  <done>
Email verification flow complete: signup triggers verification email with 24-hour token. POST /auth/verify-email validates SHA-256 hashed token, marks email as verified, deletes used token (one-time use), and auto-logs user in. POST /auth/resend-verification sends new verification email (requires login). Tokens are hashed before database storage (prevents token theft on DB compromise).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement password reset flow</name>
  <files>
    backend/src/auth/auth.service.ts
    backend/src/auth/auth.controller.ts
    backend/src/auth/dto/reset-password.dto.ts
    backend/src/auth/dto/forgot-password.dto.ts
  </files>
  <action>
**Create `backend/src/auth/dto/forgot-password.dto.ts`:**
- `email: string` -- @IsEmail()

**Create `backend/src/auth/dto/reset-password.dto.ts`:**
- `token: string` -- @IsString(), @IsNotEmpty()
- `newPassword: string` -- @MinLength(8) per user decision (8 chars min, no complexity)

**Add to `backend/src/auth/auth.service.ts`:**

1. `sendPasswordResetEmail(email: string): Promise<void>`:
   - Find user by email
   - If user not found: add artificial delay `await new Promise(r => setTimeout(r, 100))` then return silently. Per security best practice: don't reveal whether email exists.
   - If user found:
     - Delete any existing reset tokens for this user
     - Generate token: `randomBytes(32).toString('hex')`
     - Hash token: `createHash('sha256').update(token).digest('hex')`
     - Store: `prisma.passwordResetToken.create({ data: { userId: user.id, token: hashedToken, expiresAt: new Date(Date.now() + 60 * 60 * 1000) } })` -- 1 hour per user decision
     - Build URL: `${process.env.FRONTEND_URL}/reset-password/${token}`
     - Call `emailService.sendPasswordResetEmail(email, resetUrl)`

2. `resetPassword(token: string, newPassword: string): Promise<void>`:
   - Hash incoming token with SHA-256
   - Find token in database: `prisma.passwordResetToken.findFirst({ where: { token: hashedToken, expiresAt: { gt: new Date() } }, include: { user: true } })`
   - If not found, throw BadRequestException('Invalid or expired reset token')
   - Hash new password: `bcrypt.hash(newPassword, 13)`
   - Update user password: `usersService.updatePassword(resetToken.userId, passwordHash)`
   - Delete used token: `prisma.passwordResetToken.delete({ where: { id: resetToken.id } })`
   - Invalidate ALL sessions per user decision: `sessionsService.removeAllUserSessions(resetToken.userId)` -- log out all devices when password is reset
   - Send notification per user decision: `emailService.sendPasswordChangedEmail(resetToken.user.email)` -- "Your password was changed" email

**Add to `backend/src/auth/auth.controller.ts`:**

1. `POST /auth/forgot-password` -- Body: ForgotPasswordDto `{ email: string }`:
   - Call authService.sendPasswordResetEmail(email)
   - ALWAYS return same message regardless of whether email exists: `{ message: 'If that email is registered, we sent a password reset link' }`
   - This prevents user enumeration

2. `POST /auth/reset-password` -- Body: ResetPasswordDto `{ token: string, newPassword: string }`:
   - Call authService.resetPassword(token, newPassword)
   - Return `{ message: 'Password reset successfully. Please log in with your new password.' }`
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- all files compile.
If Docker available:
- POST /auth/forgot-password with existing email -- should create reset token in database
- POST /auth/forgot-password with non-existent email -- should return same success message (no enumeration)
- POST /auth/reset-password with valid token and new password -- should update password, delete token, invalidate sessions
- POST /auth/reset-password with expired/invalid token -- should return 400
- After reset, old password should not work for login, new password should work
  </verify>
  <done>
Password reset flow complete: POST /auth/forgot-password sends reset email with 1-hour token (doesn't reveal if email exists -- same response always). POST /auth/reset-password validates hashed token, updates password (bcrypt work factor 13), deletes used token, invalidates ALL sessions (per user decision: log out all devices), and sends "password changed" notification email. Timing-safe approach prevents user enumeration.
  </done>
</task>

</tasks>

<verification>
- POST /auth/verify-email with valid token marks email as verified
- POST /auth/verify-email with expired/invalid token returns 400
- Verification tokens are one-time use (second attempt with same token fails)
- POST /auth/forgot-password always returns same message (no user enumeration)
- POST /auth/reset-password updates password and invalidates all sessions
- "Password changed" email is sent after successful reset
- Tokens are SHA-256 hashed before database storage
- Backend compiles with `npx tsc --noEmit`
</verification>

<success_criteria>
Users can verify email via link (24h expiry), resend verification (while logged in), request password reset (1h expiry), and set new password (invalidates all sessions, sends notification). All tokens are hashed before storage, consumed after use, and checked for expiry. Password reset doesn't reveal whether email exists.
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-security/02-04-SUMMARY.md`
</output>
